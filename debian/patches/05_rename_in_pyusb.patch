Index: ubertooth/host/python/usb/ubertooth_pyusb/__init__.py
===================================================================
--- ubertooth.orig/host/python/usb/ubertooth_pyusb/__init__.py	2014-12-09 18:45:35.436417856 +0100
+++ ubertooth/host/python/usb/ubertooth_pyusb/__init__.py	2014-12-09 18:46:12.508417619 +0100
@@ -36,7 +36,7 @@
     control - USB standard control requests.
     libloader - helper module for backend library loading.
 
-Since version 1.0, main PyUSB implementation lives in the 'usb.core'
+Since version 1.0, main PyUSB implementation lives in the 'ubertooth_pyusb.core'
 module. New applications are encouraged to use it.
 """
 
@@ -52,7 +52,7 @@
 __all__ = ['legacy', 'control', 'core', 'backend', 'util', 'libloader']
 
 def _setup_log():
-    from usb import _debug
+    from ubertooth_pyusb import _debug
     logger = logging.getLogger('usb')
     debug_level = os.getenv('PYUSB_DEBUG')
 
@@ -94,4 +94,4 @@
 
 # We import all 'legacy' module symbols to provide compatibility
 # with applications that use 0.x versions.
-from usb.legacy import *
+from ubertooth_pyusb.legacy import *
Index: ubertooth/host/python/usb/ubertooth_pyusb/_debug.py
===================================================================
--- ubertooth.orig/host/python/usb/ubertooth_pyusb/_debug.py	2014-12-09 18:45:35.436417856 +0100
+++ ubertooth/host/python/usb/ubertooth_pyusb/_debug.py	2014-12-09 18:46:12.508417619 +0100
@@ -31,7 +31,7 @@
 __all__ = ['methodtrace', 'functiontrace']
 
 import logging
-import usb._interop as _interop
+import ubertooth_pyusb._interop as _interop
 
 _enable_tracing = False
 
Index: ubertooth/host/python/usb/ubertooth_pyusb/_lookup.py
===================================================================
--- ubertooth.orig/host/python/usb/ubertooth_pyusb/_lookup.py	2014-12-09 18:45:35.436417856 +0100
+++ ubertooth/host/python/usb/ubertooth_pyusb/_lookup.py	2014-12-09 18:46:12.508417619 +0100
@@ -26,7 +26,7 @@
 # NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
 # MODIFICATIONS.
 
-r"""usb._lookups - Lookup tables for USB
+r"""ubertooth_pyusb._lookups - Lookup tables for USB
 """
 
 descriptors = {
Index: ubertooth/host/python/usb/ubertooth_pyusb/backend/__init__.py
===================================================================
--- ubertooth.orig/host/python/usb/ubertooth_pyusb/backend/__init__.py	2014-12-09 18:40:11.140419932 +0100
+++ ubertooth/host/python/usb/ubertooth_pyusb/backend/__init__.py	2014-12-09 18:46:12.508417619 +0100
@@ -26,7 +26,7 @@
 # NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
 # MODIFICATIONS.
 
-r"""usb.backend - Backend interface.
+r"""ubertooth_pyusb.backend - Backend interface.
 
 This module exports:
 
@@ -41,26 +41,26 @@
 object. You can provide your own customized backend if you
 want to. Bellow you find a skeleton of a backend implementation module:
 
-import usb.backend
+import ubertooth_pyusb.backend
 
-class MyBackend(usb.backend.IBackend):
+class MyBackend(ubertooth_pyusb.backend.IBackend):
     pass
 
 def get_backend():
     return MyBackend()
 
 You can use your customized backend by passing it as the backend parameter of the
-usb.core.find() function. For example:
+ubertooth_pyusb.core.find() function. For example:
 
 import custom_backend
-import usb.core
+import ubertooth_pyusb.core
 
 myidVendor = 0xfffe
 myidProduct = 0x0001
 
 mybackend = custom_backend.get_backend()
 
-dev = usb.core.find(backend = mybackend, idProduct=myidProduct,
+dev = ubertooth_pyusb.core.find(backend = mybackend, idProduct=myidProduct,
                     idVendor=myidVendor)
 
 For custom backends, you are not required to supply the get_backend() function,
Index: ubertooth/host/python/usb/ubertooth_pyusb/backend/libusb0.py
===================================================================
--- ubertooth.orig/host/python/usb/ubertooth_pyusb/backend/libusb0.py	2014-12-09 18:40:11.144419932 +0100
+++ ubertooth/host/python/usb/ubertooth_pyusb/backend/libusb0.py	2014-12-09 18:46:12.508417619 +0100
@@ -28,22 +28,22 @@
 
 from ctypes import *
 import os
-import usb.backend
-import usb.util
+import ubertooth_pyusb.backend
+import ubertooth_pyusb.util
 import sys
-from usb.core import USBError
-from usb._debug import methodtrace
-import usb._interop as _interop
+from ubertooth_pyusb.core import USBError
+from ubertooth_pyusb._debug import methodtrace
+import ubertooth_pyusb._interop as _interop
 import logging
-import usb.libloader
+import ubertooth_pyusb.libloader
 
 __author__ = 'Wander Lairson Costa'
 
 __all__ = ['get_backend']
 
-_logger = logging.getLogger('usb.backend.libusb0')
+_logger = logging.getLogger('ubertooth_pyusb.backend.libusb0')
 
-# usb.h
+# ubertooth_pyusb.h
 
 _PC_PATH_MAX = 4
 
@@ -188,7 +188,7 @@
 _lib = None
 
 def _load_library(find_library=None):
-    return usb.libloader.load_locate_library(
+    return ubertooth_pyusb.libloader.load_locate_library(
                 ('usb-0.1', 'usb', 'libusb0'),
                 'cygusb0.dll', 'Libusb 0',
                 find_library=find_library
@@ -380,7 +380,7 @@
     raise USBError(errmsg, ret)
 
 # implementation of libusb 0.1.x backend
-class _LibUSB(usb.backend.IBackend):
+class _LibUSB(ubertooth_pyusb.backend.IBackend):
     @methodtrace(_logger)
     def enumerate_devices(self):
         _check(_lib.usb_find_busses())
@@ -444,12 +444,12 @@
 
     @methodtrace(_logger)
     def get_configuration(self, dev_handle):
-        bmRequestType = usb.util.build_request_type(
-                                usb.util.CTRL_IN,
-                                usb.util.CTRL_TYPE_STANDARD,
-                                usb.util.CTRL_RECIPIENT_DEVICE
+        bmRequestType = ubertooth_pyusb.util.build_request_type(
+                                ubertooth_pyusb.util.CTRL_IN,
+                                ubertooth_pyusb.util.CTRL_TYPE_STANDARD,
+                                ubertooth_pyusb.util.CTRL_RECIPIENT_DEVICE
                             )
-        buff = usb.util.create_buffer(1)
+        buff = ubertooth_pyusb.util.create_buffer(1)
         ret = self.ctrl_transfer(
                 dev_handle,
                 bmRequestType,
@@ -571,7 +571,7 @@
             _setup_prototypes(_lib)
             _lib.usb_init()
         return _LibUSB()
-    except usb.libloader.LibaryException:
+    except ubertooth_pyusb.libloader.LibaryException:
         # exception already logged (if any)
         _logger.error('Error loading libusb 0.1 backend', exc_info=False)
         return None
Index: ubertooth/host/python/usb/ubertooth_pyusb/backend/libusb1.py
===================================================================
--- ubertooth.orig/host/python/usb/ubertooth_pyusb/backend/libusb1.py	2014-12-09 18:40:11.144419932 +0100
+++ ubertooth/host/python/usb/ubertooth_pyusb/backend/libusb1.py	2014-12-09 18:46:12.508417619 +0100
@@ -27,15 +27,15 @@
 # MODIFICATIONS.
 
 from ctypes import *
-import usb.util
+import ubertooth_pyusb.util
 import sys
 import logging
-from usb._debug import methodtrace
-import usb._interop as _interop
+from ubertooth_pyusb._debug import methodtrace
+import ubertooth_pyusb._interop as _interop
 import errno
 import math
-from usb.core import USBError
-import usb.libloader
+from ubertooth_pyusb.core import USBError
+import ubertooth_pyusb.libloader
 
 __author__ = 'Wander Lairson Costa'
 
@@ -64,9 +64,9 @@
             'LIBUSB_TRANSFER_OVERFLOW'
         ]
 
-_logger = logging.getLogger('usb.backend.libusb1')
+_logger = logging.getLogger('ubertooth_pyusb.backend.libusb1')
 
-# libusb.h
+# libubertooth_pyusb.h
 
 # transfer_type codes
 # Control endpoint
@@ -267,14 +267,14 @@
     # Windows backend uses stdcall calling convention
     #
     # On FreeBSD 8/9, libusb 1.0 and libusb 0.1 are in the same shared
-    # object libusb.so, so if we found libusb library name, we must assure
+    # object libubertooth_pyusb.so, so if we found libusb library name, we must assure
     # it is 1.0 version. We just try to get some symbol from 1.0 version
     if sys.platform == 'win32':
         win_cls = WinDLL
     else:
         win_cls = None
 
-    return usb.libloader.load_locate_library(
+    return ubertooth_pyusb.libloader.load_locate_library(
                 ('usb-1.0', 'libusb-1.0', 'usb'),
                 'cygusb-1.0.dll', 'Libusb 1',
                 win_cls=win_cls,
@@ -472,7 +472,7 @@
     #               unsigned int length
     #           );
     def libusb_set_iso_packet_lengths(transfer_p, length):
-        r"""This function is inline in the libusb.h file, so we must implement
+        r"""This function is inline in the libubertooth_pyusb.h file, so we must implement
             it.
 
         lib.libusb_set_iso_packet_lengths.argtypes = [
@@ -503,7 +503,7 @@
     #           );
     def libusb_fill_iso_transfer(_libusb_transfer_p, dev_handle, endpoint, buffer, length,
                                  num_iso_packets, callback, user_data, timeout):
-        r"""This function is inline in the libusb.h file, so we must implement
+        r"""This function is inline in the libubertooth_pyusb.h file, so we must implement
             it.
 
         lib.libusb_fill_iso_transfer.argtypes = [
@@ -656,15 +656,15 @@
             self.__callback_done = 1
         else:
             status = int(transfer.contents.status)
-            raise usb.USBError(_str_transfer_error[status],
+            raise ubertooth_pyusb.USBError(_str_transfer_error[status],
                                status,
                                _transfer_errno[status])
 
 # implementation of libusb 1.0 backend
-class _LibUSB(usb.backend.IBackend):
+class _LibUSB(ubertooth_pyusb.backend.IBackend):
     @methodtrace(_logger)
     def __init__(self, lib):
-        usb.backend.IBackend.__init__(self)
+        ubertooth_pyusb.backend.IBackend.__init__(self)
         self.lib = lib
         self.ctx = c_void_p()
         _check(self.lib.libusb_init(byref(self.ctx)))
@@ -887,7 +887,7 @@
             _lib = _load_library(find_library=find_library)
             _setup_prototypes(_lib)
         return _LibUSB(_lib)
-    except usb.libloader.LibaryException:
+    except ubertooth_pyusb.libloader.LibaryException:
         # exception already logged (if any)
         _logger.error('Error loading libusb 1.0 backend', exc_info=False)
         return None
Index: ubertooth/host/python/usb/ubertooth_pyusb/backend/openusb.py
===================================================================
--- ubertooth.orig/host/python/usb/ubertooth_pyusb/backend/openusb.py	2014-12-09 18:40:11.144419932 +0100
+++ ubertooth/host/python/usb/ubertooth_pyusb/backend/openusb.py	2014-12-09 18:46:12.508417619 +0100
@@ -28,15 +28,15 @@
 
 from ctypes import *
 import ctypes.util
-import usb.util
-from usb._debug import methodtrace
+import ubertooth_pyusb.util
+from ubertooth_pyusb._debug import methodtrace
 import logging
 import errno
 import sys
-import usb._interop as _interop
-import usb.util as util
-import usb.libloader
-from usb.core import USBError
+import ubertooth_pyusb._interop as _interop
+import ubertooth_pyusb.util as util
+import ubertooth_pyusb.libloader
+from ubertooth_pyusb.core import USBError
 
 __author__ = 'Wander Lairson Costa'
 
@@ -75,7 +75,7 @@
             'OPENUSB_IO_CANCELED'
         ]
 
-_logger = logging.getLogger('usb.backend.openusb')
+_logger = logging.getLogger('ubertooth_pyusb.backend.openusb')
 
 OPENUSB_SUCCESS = 0
 OPENUSB_PLATFORM_FAILURE = -1
@@ -266,7 +266,7 @@
     # FIXME: cygwin name is "openusb"?
     #        (that's what the original _load_library() function
     #         would have searched for)
-    return usb.libloader.load_locate_library(
+    return ubertooth_pyusb.libloader.load_locate_library(
         ('openusb',), 'openusb', "OpenUSB library", find_library=find_library
     )
 
@@ -542,7 +542,7 @@
     def __del__(self):
         _lib.openusb_free_devid_list(self.devlist)
 
-class _OpenUSB(usb.backend.IBackend):
+class _OpenUSB(ubertooth_pyusb.backend.IBackend):
     @methodtrace(_logger)
     def enumerate_devices(self):
         for bus in _BusIterator():
@@ -700,7 +700,7 @@
         request.setup.wIndex
         request.timeout = timeout
 
-        direction = usb.util.ctrl_direction(bmRequestType)
+        direction = ubertooth_pyusb.util.ctrl_direction(bmRequestType)
 
         payload, request.length = data.buffer_info()
         request.length *= data.itemsize
@@ -737,7 +737,7 @@
             _setup_prototypes(_lib)
             _ctx = _Context()
         return _OpenUSB()
-    except usb.libloader.LibaryException:
+    except ubertooth_pyusb.libloader.LibaryException:
         # exception already logged (if any)
         _logger.error('Error loading OpenUSB backend', exc_info=False)
         return None
Index: ubertooth/host/python/usb/ubertooth_pyusb/control.py
===================================================================
--- ubertooth.orig/host/python/usb/ubertooth_pyusb/control.py	2014-12-09 18:45:35.440417856 +0100
+++ ubertooth/host/python/usb/ubertooth_pyusb/control.py	2014-12-09 18:46:12.508417619 +0100
@@ -26,7 +26,7 @@
 # NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
 # MODIFICATIONS.
 
-r"""usb.control - USB standard control requests
+r"""ubertooth_pyusb.control - USB standard control requests
 
 This module exports:
 
@@ -59,8 +59,8 @@
            'U2_ENABLE',
            'LTM_ENABLE']
 
-import usb.util as util
-import usb.core as core
+import ubertooth_pyusb.util as util
+import ubertooth_pyusb.core as core
 
 def _parse_recipient(recipient, direction):
     if recipient is None:
Index: ubertooth/host/python/usb/ubertooth_pyusb/core.py
===================================================================
--- ubertooth.orig/host/python/usb/ubertooth_pyusb/core.py	2014-12-09 18:45:35.440417856 +0100
+++ ubertooth/host/python/usb/ubertooth_pyusb/core.py	2014-12-09 18:46:12.508417619 +0100
@@ -26,7 +26,7 @@
 # NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
 # MODIFICATIONS.
 
-r"""usb.core - Core USB features.
+r"""ubertooth_pyusb.core - Core USB features.
 
 This module exports:
 
@@ -43,15 +43,15 @@
 __all__ = [ 'Device', 'Configuration', 'Interface', 'Endpoint', 'find',
             'show_devices' ]
 
-import usb.util as util
+import ubertooth_pyusb.util as util
 import copy
 import operator
-import usb._interop as _interop
-import usb._lookup as _lu
+import ubertooth_pyusb._interop as _interop
+import ubertooth_pyusb._lookup as _lu
 import logging
 import array
 
-_logger = logging.getLogger('usb.core')
+_logger = logging.getLogger('ubertooth_pyusb.core')
 
 _DEFAULT_TIMEOUT = 1000
 
@@ -256,8 +256,8 @@
     USB Specification. You can access them as class properties. For example, to
     access the field bEndpointAddress of the endpoint descriptor, you can do so:
 
-    >>> import usb.core
-    >>> dev = usb.core.find()
+    >>> import ubertooth_pyusb.core
+    >>> dev = ubertooth_pyusb.core.find()
     >>> for cfg in dev:
     >>>     for i in cfg:
     >>>         for e in i:
@@ -386,8 +386,8 @@
     properties. For example, to access the field bInterfaceNumber
     of the interface descriptor, you can do so:
 
-    >>> import usb.core
-    >>> dev = usb.core.find()
+    >>> import ubertooth_pyusb.core
+    >>> dev = ubertooth_pyusb.core.find()
     >>> for cfg in dev:
     >>>     for i in cfg:
     >>>         print i.bInterfaceNumber
@@ -523,8 +523,8 @@
     example, to access the field bConfigurationValue of the configuration
     descriptor, you can do so:
 
-    >>> import usb.core
-    >>> dev = usb.core.find()
+    >>> import ubertooth_pyusb.core
+    >>> dev = ubertooth_pyusb.core.find()
     >>> for cfg in dev:
     >>>     print cfg.bConfigurationValue
     """
@@ -652,8 +652,8 @@
     to access the field bDescriptorType of the device descriptor, you can
     do so:
 
-    >>> import usb.core
-    >>> dev = usb.core.find()
+    >>> import ubertooth_pyusb.core
+    >>> dev = ubertooth_pyusb.core.find()
     >>> dev.bDescriptorType
 
     Additionally, the class provides methods to communicate with the hardware.
@@ -665,8 +665,8 @@
 
     When working in a new hardware, the first try could be like this:
 
-    >>> import usb.core
-    >>> dev = usb.core.find(idVendor=myVendorId, idProduct=myProductId)
+    >>> import ubertooth_pyusb.core
+    >>> dev = ubertooth_pyusb.core.find(idVendor=myVendorId, idProduct=myProductId)
     >>> dev.set_configuration()
     >>> dev.write(1, 'test')
 
@@ -826,7 +826,7 @@
 
         >>> try:
         >>>     dev.set_interface_altsetting()
-        >>> except usb.core.USBError:
+        >>> except ubertooth_pyusb.core.USBError:
         >>>     pass
         """
         self._ctx.managed_set_interface(self, interface, alternate_setting)
@@ -1135,11 +1135,11 @@
     so:
 
     def is_printer(dev):
-        import usb.util
+        import ubertooth_pyusb.util
         if dev.bDeviceClass == 7:
             return True
         for cfg in dev:
-            if usb.util.find_descriptor(cfg, bInterfaceClass=7) is not None:
+            if ubertooth_pyusb.util.find_descriptor(cfg, bInterfaceClass=7) is not None:
                 return True
 
     for printer in find(find_all=True, custom_match = is_printer):
@@ -1164,11 +1164,11 @@
 
     find(backend = MyBackend())
 
-    PyUSB has builtin backends for libusb 0.1, libusb 1.0 and OpenUSB.  If you
+    PyUSB has builtin backends for libusb 0.1, libusb 1.0 and Openubertooth_pyusb.  If you
     do not supply a backend explicitly, find() function will select one of the
     predefineds backends according to system availability.
 
-    Backends are explained in the usb.backend module.
+    Backends are explained in the ubertooth_pyusb.backend module.
     """
 
     def device_iter(k, v):
@@ -1186,9 +1186,9 @@
                 yield d
 
     if backend is None:
-        import usb.backend.libusb1 as libusb1
-        import usb.backend.libusb0 as libusb0
-        import usb.backend.openusb as openusb
+        import ubertooth_pyusb.backend.libusb1 as libusb1
+        import ubertooth_pyusb.backend.libusb0 as libusb0
+        import ubertooth_pyusb.backend.openusb as openusb
 
         for m in (libusb1, openusb, libusb0):
             backend = m.get_backend()
Index: ubertooth/host/python/usb/ubertooth_pyusb/legacy.py
===================================================================
--- ubertooth.orig/host/python/usb/ubertooth_pyusb/legacy.py	2014-12-09 18:45:35.440417856 +0100
+++ ubertooth/host/python/usb/ubertooth_pyusb/legacy.py	2014-12-09 18:46:12.508417619 +0100
@@ -26,10 +26,10 @@
 # NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
 # MODIFICATIONS.
 
-import usb.core as core
-import usb.util as util
-import usb._interop as _interop
-import usb.control as control
+import ubertooth_pyusb.core as core
+import ubertooth_pyusb.util as util
+import ubertooth_pyusb._interop as _interop
+import ubertooth_pyusb.control as control
 
 __author__ = 'Wander Lairson Costa'
 
Index: ubertooth/host/python/usb/ubertooth_pyusb/libloader.py
===================================================================
--- ubertooth.orig/host/python/usb/ubertooth_pyusb/libloader.py	2014-12-09 18:45:35.440417856 +0100
+++ ubertooth/host/python/usb/ubertooth_pyusb/libloader.py	2014-12-09 18:46:12.508417619 +0100
@@ -45,7 +45,7 @@
 ]
 
 
-_LOGGER = logging.getLogger('usb.libloader')
+_LOGGER = logging.getLogger('ubertooth_pyusb.libloader')
 
 
 class LibaryException(OSError):
Index: ubertooth/host/python/usb/ubertooth_pyusb/util.py
===================================================================
--- ubertooth.orig/host/python/usb/ubertooth_pyusb/util.py	2014-12-09 18:45:35.440417856 +0100
+++ ubertooth/host/python/usb/ubertooth_pyusb/util.py	2014-12-09 18:46:12.508417619 +0100
@@ -26,7 +26,7 @@
 # NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
 # MODIFICATIONS.
 
-r"""usb.util - Utility functions.
+r"""ubertooth_pyusb.util - Utility functions.
 
 This module exports:
 
@@ -46,7 +46,7 @@
 
 import operator
 import array
-import usb._interop as _interop
+import ubertooth_pyusb._interop as _interop
 
 # descriptor type
 DESC_TYPE_DEVICE = 0x01
@@ -245,7 +245,7 @@
 
     The return value is the unicode string present in the descriptor.
     """
-    from usb.control import get_descriptor
+    from ubertooth_pyusb.control import get_descriptor
     if langid is None:
 	# Asking for the zero'th index is special - it returns a string
 	# descriptor that contains all the language IDs supported by the device.
